\hypertarget{class_trace_timer}{}\section{Trace\+Timer Class Reference}
\label{class_trace_timer}\index{Trace\+Timer@{Trace\+Timer}}


{\ttfamily \#include $<$C\+H\+\_\+\+Timer.\+H$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_trace_timer_a03205e8ad8c9ce4564d686707f82fe84}\label{class_trace_timer_a03205e8ad8c9ce4564d686707f82fe84}} 
void {\bfseries start} (char $\ast$mutex)
\item 
\mbox{\Hypertarget{class_trace_timer_a690e043d786547decec8c483cf662ca1}\label{class_trace_timer_a690e043d786547decec8c483cf662ca1}} 
unsigned long long int {\bfseries stop} (char $\ast$mutex)
\item 
\mbox{\Hypertarget{class_trace_timer_adf7648634d5812e6d9d5de15f00e8314}\label{class_trace_timer_adf7648634d5812e6d9d5de15f00e8314}} 
void {\bfseries leaf\+Start} ()
\item 
\mbox{\Hypertarget{class_trace_timer_a79a39ed75671663311d05fcfbb9c4ad7}\label{class_trace_timer_a79a39ed75671663311d05fcfbb9c4ad7}} 
void {\bfseries leaf\+Stop} ()
\item 
\mbox{\Hypertarget{class_trace_timer_a103b200bed76e219ad74124f6390d0a6}\label{class_trace_timer_a103b200bed76e219ad74124f6390d0a6}} 
unsigned long long int {\bfseries time} () const
\item 
\mbox{\Hypertarget{class_trace_timer_afa5f369cbff76aab55e37546c1d6757c}\label{class_trace_timer_afa5f369cbff76aab55e37546c1d6757c}} 
int {\bfseries rank} () const
\item 
\mbox{\Hypertarget{class_trace_timer_a88d9f956dd68a6ae9edf55ef17d00ffa}\label{class_trace_timer_a88d9f956dd68a6ae9edf55ef17d00ffa}} 
long long int {\bfseries count} () const
\item 
\mbox{\Hypertarget{class_trace_timer_a368f32b604ecd500afb084851e8c51ce}\label{class_trace_timer_a368f32b604ecd500afb084851e8c51ce}} 
void {\bfseries prune} ()
\item 
\mbox{\Hypertarget{class_trace_timer_abe018a441daabb949a6ad270614c7dfd}\label{class_trace_timer_abe018a441daabb949a6ad270614c7dfd}} 
bool {\bfseries is\+Pruned} () const
\item 
\mbox{\Hypertarget{class_trace_timer_ab0d8760ddb993c291d2afc17fcc5b22c}\label{class_trace_timer_ab0d8760ddb993c291d2afc17fcc5b22c}} 
const std\+::vector$<$ \hyperlink{class_trace_timer}{Trace\+Timer} $\ast$ $>$ \& {\bfseries children} () const
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_trace_timer_a099a00979dce21aa8152189caa9e3664}\label{class_trace_timer_a099a00979dce21aa8152189caa9e3664}} 
static void {\bfseries report} (bool a\+\_\+close\+After=false)
\item 
\mbox{\Hypertarget{class_trace_timer_a9c51438e2ce920545955f6b03d1959aa}\label{class_trace_timer_a9c51438e2ce920545955f6b03d1959aa}} 
static void {\bfseries reset} ()
\item 
\mbox{\Hypertarget{class_trace_timer_ad2418f864f19ff1af50a7dd86d1ac572}\label{class_trace_timer_ad2418f864f19ff1af50a7dd86d1ac572}} 
static int {\bfseries initializer} ()
\item 
\mbox{\Hypertarget{class_trace_timer_a2f3e79338d3f21acc37bcf9a12cc67ae}\label{class_trace_timer_a2f3e79338d3f21acc37bcf9a12cc67ae}} 
static \hyperlink{class_trace_timer}{Trace\+Timer} $\ast$ {\bfseries get\+Timer} (const char $\ast$name)
\item 
\mbox{\Hypertarget{class_trace_timer_a5195aa7537a7db853ce2ec8259ad5755}\label{class_trace_timer_a5195aa7537a7db853ce2ec8259ad5755}} 
static void {\bfseries Prune\+Timers\+Parent\+Child\+Percent} (double percent)
\item 
\mbox{\Hypertarget{class_trace_timer_af57bb1e97bf05e30a71b09c68bd14370}\label{class_trace_timer_af57bb1e97bf05e30a71b09c68bd14370}} 
static void {\bfseries sample\+Mem\+Usage} ()
\item 
\mbox{\Hypertarget{class_trace_timer_a4360f840af3e64a931860d64fb35569f}\label{class_trace_timer_a4360f840af3e64a931860d64fb35569f}} 
static const char $\ast$ {\bfseries current\+Timer} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{class_trace_timer}{Trace\+Timer} class is a self-\/tracing code instrumentation system

\hyperlink{class_trace_timer}{Trace\+Timer} class is a self-\/tracing code instrumentation system for Chombo (or any other package really). The user interface is specified by a small set of macros. The usage model is that you just leave these timers in the code, for good. Initially, your application will have \textquotesingle{}main\textquotesingle{} and a few hewavy functions instrumented, and the lower level Chombo library instrumentation. As your tool or application matures, it will garner a larger set of instrumentation giving clear views of your code performance. After a routine has been cleverly and lovingly optimized, you leave in the timers, to spot when some later bug fix or {\itshape improvement} undoes your previous labors.

\begin{DoxyNote}{Note}
You should never need to use or interact with the the classes \hyperlink{class_trace_timer}{Trace\+Timer} or \hyperlink{class_auto_start}{Auto\+Start}. Use the macros. They call the right functions and classes for you.
\end{DoxyNote}
The first macro is what people will use the most\+: 
\begin{DoxyCode}
CH\_TIME(\textcolor{stringliteral}{"label"});
\end{DoxyCode}
 \begin{DoxyVerb} This is the simplest interface for timers.  you place this macro call in a function
 you wish to be timed.  It handles making the timer, calling 'start' when you
 enter the function, and calling 'stop' when you leave the function.  A good
 idea is to use a 'label' specific enough to be unambiguous without being
 overwhelming.  for instance:
\end{DoxyVerb}



\begin{DoxyCode}
\textcolor{keywordtype}{void} AMRLevelPolytropicGas::define(AMRLevel*            a\_coarserLevelPtr,
                                   \textcolor{keyword}{const} ProblemDomain& a\_problemDomain,
                                   \textcolor{keywordtype}{int}                  a\_level,
                                   \textcolor{keywordtype}{int}                  a\_refRatio)
\{
   CH\_TIME(\textcolor{stringliteral}{"AMRLevelPolytropicGas::define"});
 .
 .
\}
\end{DoxyCode}
 \begin{DoxyVerb} In this case, we have a class with many constructors and define functions that
 all funnel into a single general function.  We can just call this 'define' and
 not worry about naming/instrumenting all the different overloaded instances. If
 you slip up and use the same label twice, that is not a real problem, the two
 locations will be timed and tracked properly (even if one is a sibling or parent
 of the other). The only place it will make things a little harder is in the output
 where you might have the same name show up and look confusing.
<br><br>
 In serial, you will see a file called <em>time.table</em> (in parallel, you will get a
 <em>time.table.n</em> (where n is the rank number) files).  If
 you want fewer files, you can do 
 setenv CH_OUTPUT_INTERVAL nproc 
 and it will only output every nproc processors time.table.n files
 (where n%nproc == 0).     I won't go into this file
 format.  It is kind of gprof-ish, with what I consider improvements.  The real
 benefit here is profiling that understands our Chombo context, a smaller information
 set to observe, and the fact that, so far in my testing, the timers have negligible
 impact on the run time or memory use of the code.
 <br><br>
 By default, Chombo compiles in the instructions for the timers wherever the macros
 appear.  If the compiler macro <b>CH_NTIMER</b> is defined, then all the CH_TIME* macros
 evaluate to empty expressions at compile time.

 \par So, you put some CH_TIME calls in your code and ran it, and nothing happened:
 Chombo looks for the environment variable <b>CH_TIMER</b>. If it is set to anything (even
 if it is set to 'false' or 'no' or whatever) then the timers will be active and
 reporting will happen.  If this environment variable is not set, then all the timers
 check a bool and return after doing nothing.
 \par
 One point of interest with using the environment variable: In parallel jobs using
 mpich, only processor 0 inherits the environment variables from the shell where
 you invoke 'mpirun', the rest read your .cshrc (.bashrc, etc.) file to get their
 environment.  To time all your processes, you need to make sure the <b>CH_TIMER</b>
 environment variable gets to all your processes.



 \par Auto hierarchy:
 The timers automatically figure out their parent/child relationships.  They
 also can be placed in template code.  This has some consequences.  First,
 if you have a low level function instrumented that has no timers near it in
 the code call stack, you will see it show up as a child of a high level timer.
 the root timer "main" will catch all orphaned timers.  So, even though you
 might make no call to, say, 'exchange' in your 'main' function, you might
 very well call a function, that calls a function, that calls 'exchange'. Since
 no code in between was instrumented, this exchange is accounted for at 'main'.
 This might look strange, but it should prove very powerful. An expensive orphan
 is exactly where you should consider some more timers, or reconsidering code
 design.

 \par
  For performance reasons, child timers have only one parent.  As a consequence
  each CH_TIME("label") label can show up at multiple places in your output. Each
  instance has it's own timer.  So, each path through the call graph that arrives
  at a low-level function has a unique lineage, with it's own counter and time.
  Thus, I can instrument LevelData::copyTo once, but copyTo can appear in many
  places in the time.table file.


 The next level up in complexity is the set of *four* macros for when you want
 sub-function resolution in your timers. For instance, in a really huge function
 that you have not figured out how to re-factor, or built with lots of bad cut n paste
 code 're-use'.
\end{DoxyVerb}
 
\begin{DoxyCode}
CH\_TIMERS(\textcolor{stringliteral}{"parent"});
CH\_TIMER(\textcolor{stringliteral}{"child1"}, t1);
CH\_TIMER(\textcolor{stringliteral}{"child2"}, t2);
CH\_START(t1);
CH\_STOP(t1);
CH\_START(t2);
CH\_STOP(t2);
CH\_START(t1);
CH\_STOP(t1);
\end{DoxyCode}
 \begin{DoxyVerb} CH_TIMERS has the same semantic as CH_TIME, except that you can declare an
 arbitrary number of children after it in the same function scope.  The
 children here do not autostart and autostop, you have to tell them where to
 start and stop timing.  The children can themselves be parents for timers
 in called functions, of course. The children obey a set of mutual exclusions. The
 following generate run time errors:
 - double start called
 - double stop called
 - start called when another child is also started
 - you leave the function with a child not stopped

 the following will generate compile time errors:
 - more than one CH_TIME macro in a function
 - invoking CH_TIMER("child", t) without having first invoked CH_TIMERS
 - re-using the timer handle ie. CH_TIMER("bobby", t1); CH_TIMER("sally", t1)
 - mixing CH_TIME macro with CH_TIMER
 - mixing CH_TIME macro with CH_TIMERS

 You do not have to put any calls in your main routine to activate the clocks
 or generate a report at completion, this is handled with static iniitalization
 and an atexit function.
 <br><br>
 There is a larger argument of manual instrumentation being counter to good development.
 Profiling the code is supposed to tell you where to expend your optimization effort.
 Manual instrumentation opens the door to people wasting time *assuming* what parts of the
 code are going to take up lots of time and instrumenting them, before seeing any real
 performance data.  Good judgement is needed.  We have a body of knowledge about Chombo
 that will inform us about a good minimal first set of functions to instrument.\end{DoxyVerb}
 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
utils/timer/C\+H\+\_\+\+Timer.\+H\item 
utils/timer/C\+H\+\_\+\+Timer.\+cpp\end{DoxyCompactItemize}
